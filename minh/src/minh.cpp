#include <ros/ros.h>
#include <geometry_msgs/Twist.h>
#include <signal.h>
#include <termios.h>
#include <stdio.h>

#define KEYCODE_R 0x43
#define KEYCODE_L 0x44
#define KEYCODE_U 0x41
#define KEYCODE_D 0x42
#define KEYCODE_Q 0x71
#define KEYCODE_SPACE 0x20
#define KEYCODE_DEMO 0x01
 
  /*
  int tcsetattr(int fildes, int optional_actions, const struct termios *termios_p);

  tcsetattr Thiet lap cac tham so lien ket (parameters associated) voi thiet bi dau cuoi (terminal)
  boi file descriptor fildes mo kfd (file nay lien ket den terminal) 
  tu mot cau truc termios duoc goi boi cooked

  TCSANOW : neu co su thay doi, su thay doi do se duoc ap dung (luu) ngay lap tuc

  http://pubs.opengroup.org/onlinepubs/009695399/functions/tcsetattr.html
  */
  ros::shutdown();
  exit(0);
}
int main(int argc, char** argv)
{
  ros::init(argc, argv, "teleop_RosAria");
  TeleopRosAria teleop_RosAria;
  signal(SIGINT,quit);
  /*
  void (*signal(int sig, void (*func)(int)))(int);

  thiet lap cach xu ly tin hieu voi signal number duoc chi dinh boi sig
  trong truong hop nay, sig la SIGINT (signal interrupt) 
  nghia la Interactive attention signal. Generally generated by the application user.

  http://www.cplusplus.com/reference/csignal/signal/
  */
  teleop_RosAria.keyLoop();
  return(0);
}
void TeleopRosAria::keyLoop()
{
  char c;
  bool dirty=false;
  // get the console in raw mode
  tcgetattr(kfd, &cooked);
  memcpy(&raw, &cooked, sizeof(struct termios));
  /*
  copy block of memory
  Copies the values of sizeof(struct termios) bytes (copy so byte bang kich thuoc cua termios)
  from the location pointed to by cooked directly 
  to the memory block pointed to by raw.
  */
  raw.c_lflag &=~ (ICANON | ECHO);
  // Setting a new line, then end of file
  raw.c_cc[VEOL] = 1;
  raw.c_cc[VEOF] = 2;
  tcsetattr(kfd, TCSANOW, &raw);
  puts("Reading from keyboard");
  puts("---------------------------");
  puts("Use arrow keys to move the robot.");
  puts("Press the space bar to stop the robot.");
  puts("Press q to stop the program");
  for(;;)
  {
    // get the next event from the keyboard
    if(read(kfd, &c, 1) < 0)
	  {
  	  perror("read():"); // print error massage
  	  exit(-1);
	  }
    linear_=angular_=0;
    ROS_DEBUG("value: 0x%02X\n", c);
    switch(c)
	  {
    	case KEYCODE_L:
    	  ROS_DEBUG("LEFT");
    	  angular_ = 1;
    	  linear_ = 0;
    	  dirty = true;
    	  break;
    	case KEYCODE_R:
    	  ROS_DEBUG("RIGHT");
    	  angular_ = -1;
    	  linear_ = 0;
    	  dirty = true;
    	  break;
    	case KEYCODE_U:
    	  ROS_DEBUG("UP");
    	  linear_ = 1;
    	  angular_ = 0;
    	  dirty = true;
    	  break;
    	case KEYCODE_D:
    	  ROS_DEBUG("DOWN");
    	  linear_ = -1;
    	  angular_ = 0;
    	  dirty = true;
    	  break;
    	case KEYCODE_SPACE:
    	  ROS_DEBUG("STOP");
    	  linear_ = 0;
    	  angular_ = 0;
    	  dirty = true;
    	  break;
      case 0x6D: //chu m
        ROS_DEBUG("UP");
        ROS_INFO_STREAM("Ban vua nhan chu M, robot se di ve phia truoc");
        linear_ = 1;
        angular_ = 0;
        dirty = true;
        break;
      case KEYCODE_Q:
        ROS_DEBUG("QUIT");
        ROS_INFO_STREAM("You quit the teleop successfully");
        return;
        break;
  	}
    geometry_msgs::Twist twist;
    twist.angular.z = a_scale_*angular_;
    twist.linear.x = l_scale_*linear_;
    if(dirty ==true)
  	{
  	  twist_pub_.publish(twist);
  	  dirty=false;
  	}
  }
  return;
}